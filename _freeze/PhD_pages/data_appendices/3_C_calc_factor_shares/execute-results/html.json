{
  "hash": "8109bc5775da3f172c6ff66c4be703d7",
  "result": {
    "markdown": "---\ntitle: \"Calculating housing and factor shares from industry data\"\neditor: visual\nexecute:\n  freeze: true  # never re-render during project render\n---\n\n\n# To-do:\n\n- I moved the data folder, but haven't yet relected this in the code below.\n\n## Summary\n\nWe take the prepared KLEMS and OECD generation of income by industry data and calculate the labour and capital share of income, separating the housing share from the latter.\n\n(Possibly public sector too?).\n\nThe key elements are this:\n\n-   **We use factor income as the denominator\\\n    **(Explain... Jump to section)\n-   **We impute capital and labour components for the self-employed**\\\n    (Explain... Jump to section))\n-   **We prepare two alternative specifications relating to the above imputation, to handle where labour income is greater than 100% of value added**\\\n    (Explain... Jump to section)) \\\n\n## Factor income as the denominator\n\nNational accounting practices separates compensation of employees from value added (as well as taxes on production). Gross operating surplus is the residual.\n\n## Impute labour and capital components for self employed\n\nFor the purposes of calculating factor shares, this residual includes mixed income - the income of the self-employed which is generated by both their labour and capital inputs.\n\nWithin the KLEMS data, this is already separated out - using employment data... (explain).\n\nWe do the same process for OECD data.\n\n## Problem of \\>100% labour income\n\n## Two approaches\n\n## Calculate factor shares (inc. housing)\n\nTO DO: This was split out from the OECD data prep. I want to process the KLEMS data at the same time.\n\n### Factor shares from industry accounts\n\n#### Imputing self-employed labour and capital income\n\nWe have data on the number of employed and self-employed hours are worked in each industry. We also have data on the compensation of the *employed*. The task is to impute the *labour* compensation of the self-employed and then separate this out from *Gross Operating Surplus* in order to arrive at a split between capital and labour income.\n\nThe basic strategy is to apply the same hourly rate of compensation for the employed (within each industry) to the self-employed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# main_industry_accounts_inspect<- main_industry_accounts %>%\n#   mutate(COMP_per_hour = COMP/employed_hrs,\n#          COMP_SE = COMP_per_hour * self_employed_hrs,\n#          LAB = COMP + COMP_SE)\n```\n:::\n\n\nThis however creates a problem: in some cases, the total labour income implied (employed + self employed) is greater than 100% of value added. Here we show these rows grouped by industry.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# kable(\n#  br<-  main_industry_accounts_inspect %>%\n#   mutate(LAB_share = LAB/VA,\n#          LAB_share_group = cut(LAB_share,\n#                        breaks=c(-100, 1, 1.1, 1.5, 2, 10, 1000000000000),\n#                        labels=c('<100%', '100-110%', '110-150%', '150-200%', '200-1,000%', '1,000+'))) %>%\n#     count(ind_code, LAB_share_group) %>%\n#     pivot_wider(names_from = LAB_share_group, values_from = n)\n# )\n```\n:::\n\n\nWe take two approaches to this problem.\n\n##### Model 1 - imputation with no ceiling\n\nThe most simple approach is just to ignore the problem and allow labour income to be greater than value added. This will mean allowing capital income to be negative.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# main_industry_accounts_mod1<- main_industry_accounts %>%\n#    mutate(COMP_per_hour = COMP/employed_hrs,\n#          COMP_SE = COMP_per_hour * self_employed_hrs)\n```\n:::\n\n\n##### Model 2 - imputation with ceiling\n\nAn alternative approach is to cap self-employed labour income at the full value of *Gross Operating Surplus*. This implies that total labour incomes cannot exceed 100% of value added and total capital incomes cannot be negative.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# main_industry_accounts_mod2<- main_industry_accounts %>%\n#   mutate(COMP_per_hour = COMP/employed_hrs,\n#          COMP_SE = pmin(COMP_per_hour * self_employed_hrs, GOS))\n```\n:::\n\n\n##### Calculate labour and capital incomes\n\nOn each model, total labour income is equal to the sum of compensation of employees and the self-employed. Total gross (net) capital income is equal to *Gross (Net) Operating Surplus* minus the labour income of the self-employed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calc_LAB_CAP<- function(df){\n#   df<- df %>%\n#     mutate(LAB = COMP + COMP_SE,\n#            CAP = GOS - COMP_SE,\n#            NCAP = NOS - COMP_SE)\n# }\n# \n# main_industry_accounts_mod1<- calc_LAB_CAP(main_industry_accounts_mod1)\n# \n# main_industry_accounts_mod2<- calc_LAB_CAP(main_industry_accounts_mod2)\n```\n:::\n\n\n#### Create economy aggregates\n\nFor the calculation of factor shares, we will use the sum across industries as the denominator - rather than the reported economy-wide aggregate.\n\nthe reason for this. The implicit assumption is that whatever is 'missing' from the aggregate has a factor split equal to that found in the available industry-level data.\n\nHere we calculate the sum across industries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# agg_across_industries<- function(df){\n#   \n#   df<- df %>%\n#     group_by(country, year) %>%\n#     summarise(VA = sum(VA, na.rm = TRUE),\n#               COMP = sum(COMP, na.rm = TRUE),\n#               GOS = sum(GOS, na.rm = TRUE),\n#               COMP_SE = sum(COMP_SE, na.rm = TRUE),\n#               LAB = sum(LAB, na.rm = TRUE),\n#               CAP = sum(CAP, na.rm = TRUE),\n#               NCAP = sum(NCAP, na.rm = TRUE)\n#               )\n#  \n# }\n# \n# agg_industry_mod1<- agg_across_industries(main_industry_accounts_mod1)\n# agg_industry_mod2<- agg_across_industries(main_industry_accounts_mod2)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}