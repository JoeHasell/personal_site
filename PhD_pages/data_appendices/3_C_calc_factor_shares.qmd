---
title: "Calculating housing and factor shares from industry data"
editor: visual
execute:
  eval: false  # never run
---

# To-do:

- I moved the data folder, but haven't yet relected this in the code below.

## Summary

We take the prepared KLEMS and OECD generation of income by industry data and calculate the labour and capital share of income, separating the housing share from the latter.

(Possibly public sector too?).

The key elements are this:

-   **We use factor income as the denominator\
    **(Explain... Jump to section)
-   **We impute capital and labour components for the self-employed**\
    (Explain... Jump to section))
-   **We prepare two alternative specifications relating to the above imputation, to handle where labour income is greater than 100% of value added**\
    (Explain... Jump to section)) \

## Factor income as the denominator

National accounting practices separates compensation of employees from value added (as well as taxes on production). Gross operating surplus is the residual.

## Impute labour and capital components for self employed

For the purposes of calculating factor shares, this residual includes mixed income - the income of the self-employed which is generated by both their labour and capital inputs.

Within the KLEMS data, this is already separated out - using employment data... (explain).

We do the same process for OECD data.

## Problem of \>100% labour income

## Two approaches

## Calculate factor shares (inc. housing)

TO DO: This was split out from the OECD data prep. I want to process the KLEMS data at the same time.

### Factor shares from industry accounts

#### Imputing self-employed labour and capital income

We have data on the number of employed and self-employed hours are worked in each industry. We also have data on the compensation of the *employed*. The task is to impute the *labour* compensation of the self-employed and then separate this out from *Gross Operating Surplus* in order to arrive at a split between capital and labour income.

The basic strategy is to apply the same hourly rate of compensation for the employed (within each industry) to the self-employed.

```{r}
# main_industry_accounts_inspect<- main_industry_accounts %>%
#   mutate(COMP_per_hour = COMP/employed_hrs,
#          COMP_SE = COMP_per_hour * self_employed_hrs,
#          LAB = COMP + COMP_SE)
```

This however creates a problem: in some cases, the total labour income implied (employed + self employed) is greater than 100% of value added. Here we show these rows grouped by industry.

```{r}
# kable(
#  br<-  main_industry_accounts_inspect %>%
#   mutate(LAB_share = LAB/VA,
#          LAB_share_group = cut(LAB_share,
#                        breaks=c(-100, 1, 1.1, 1.5, 2, 10, 1000000000000),
#                        labels=c('<100%', '100-110%', '110-150%', '150-200%', '200-1,000%', '1,000+'))) %>%
#     count(ind_code, LAB_share_group) %>%
#     pivot_wider(names_from = LAB_share_group, values_from = n)
# )


```

We take two approaches to this problem.

##### Model 1 - imputation with no ceiling

The most simple approach is just to ignore the problem and allow labour income to be greater than value added. This will mean allowing capital income to be negative.

```{r}
# main_industry_accounts_mod1<- main_industry_accounts %>%
#    mutate(COMP_per_hour = COMP/employed_hrs,
#          COMP_SE = COMP_per_hour * self_employed_hrs)
```

##### Model 2 - imputation with ceiling

An alternative approach is to cap self-employed labour income at the full value of *Gross Operating Surplus*. This implies that total labour incomes cannot exceed 100% of value added and total capital incomes cannot be negative.

```{r}
# main_industry_accounts_mod2<- main_industry_accounts %>%
#   mutate(COMP_per_hour = COMP/employed_hrs,
#          COMP_SE = pmin(COMP_per_hour * self_employed_hrs, GOS))
```

##### Calculate labour and capital incomes

On each model, total labour income is equal to the sum of compensation of employees and the self-employed. Total gross (net) capital income is equal to *Gross (Net) Operating Surplus* minus the labour income of the self-employed.

```{r}
# calc_LAB_CAP<- function(df){
#   df<- df %>%
#     mutate(LAB = COMP + COMP_SE,
#            CAP = GOS - COMP_SE,
#            NCAP = NOS - COMP_SE)
# }
# 
# main_industry_accounts_mod1<- calc_LAB_CAP(main_industry_accounts_mod1)
# 
# main_industry_accounts_mod2<- calc_LAB_CAP(main_industry_accounts_mod2)

```

#### Create economy aggregates

For the calculation of factor shares, we will use the sum across industries as the denominator - rather than the reported economy-wide aggregate.

the reason for this. The implicit assumption is that whatever is 'missing' from the aggregate has a factor split equal to that found in the available industry-level data.

Here we calculate the sum across industries.

```{r}

# agg_across_industries<- function(df){
#   
#   df<- df %>%
#     group_by(country, year) %>%
#     summarise(VA = sum(VA, na.rm = TRUE),
#               COMP = sum(COMP, na.rm = TRUE),
#               GOS = sum(GOS, na.rm = TRUE),
#               COMP_SE = sum(COMP_SE, na.rm = TRUE),
#               LAB = sum(LAB, na.rm = TRUE),
#               CAP = sum(CAP, na.rm = TRUE),
#               NCAP = sum(NCAP, na.rm = TRUE)
#               )
#  
# }
# 
# agg_industry_mod1<- agg_across_industries(main_industry_accounts_mod1)
# agg_industry_mod2<- agg_across_industries(main_industry_accounts_mod2)


```
